#!/bin/bash
#
# functions used by dracut and other tools.
#
# Copyright 2005-2009 Red Hat, Inc.  All rights reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

IF_RTLD=""
IF_dynamic=""

# Generic substring function.  If $2 is in $1, return 0.
strstr() { [[ $1 =~ $2 ]]; }

# Log initrd creation.
if ! [[ $dracutlogfile ]]; then
    [[ $dsrc = /usr/share/dracut ]] && \
	dracutlogfile=/var/log/dracut.log || \
	dracutlogfile=/tmp/dracut.log
    [[ -w $dracutlogfile ]] || dracutlogfile=/tmp/dracut.log
    >"$dracutlogfile"
fi

dwarning() {
    echo "W: $@" >&2
    [[ -w $dracutlogfile ]] && echo "W: $@" >>"$dracutlogfile"
}

dinfo() {
    [[ $beverbose ]] && echo "I: $@" >&2
    [[ -w $dracutlogfile ]] && echo "I: $@" >>"$dracutlogfile"
}

derror() {
    echo "E: $@" >&2
    [[ -w $dracutlogfile ]] && echo "E: $@" >>"$dracutlogfile"
}

get_fs_type() (
    if [[ -x /lib/udev/vol_id ]]; then
	eval /usr/udev/vol_id --export $1
	echo $ID_FS_TYPE
    elif find_binary >/dev/null; then
	blkid -o value -s TYPE $1
    else
	return 1
    fi
)

# finds the major:minor of the block device backing the root filesystem.
find_block_device() {
    local rootdev blkdev fs type opts misc
    while read blkdev fs type opts misc; do
	[[ $blkdev = rootfs ]] && continue # skip rootfs entry
	[[ $fs = $1 ]] && { rootdev=$blkdev; break; } # we have a winner!
    done < /proc/mounts
    [[ -b $rootdev ]] || return 1 # oops, not a block device.
    # get major/minor for the device
    ls -nLl "$rootdev" | \
	(read x x x x maj min x; maj=${maj//,/}; echo $maj:$min)
}

find_root_block_device() { find_block_device /; }

# Walk all the slave relationships for a given block device.
# Stop when our helper function returns success
# $1 = function to call on every found block device
# $2 = block device in major:minor format
check_block_and_slaves() {    
    local x 
    [[ -b /dev/block/$2 ]] || return 1 # Not a block device? So sorry.
    "$1" $2 && return
    [[ -d /sys/dev/block/$2/slaves ]] || return 1
    # we want to search the tree breadthwise, so...
    for x in /sys/dev/block/$2/slaves/*/dev; do
        [[ -f $x ]] || continue
	$1 $(cat "$x") && return 0
    done
    for x in /sys/dev/block/$2/slaves/*/dev; do
        [[ -f $x ]] || continue
	check_block_and_slaves $1 $(cat "$x") &&  return 0
    done
    return 1
}

# $1 = file to copy to ramdisk
# $2 (optional) Name for the file on the ramdisk
# Location of the image dir is assumed to be $initdir
# We never overwrite the target if it exists.
inst_simple() {
    local src target
    [[ -f $1 ]] || return 1
    src=$1 target=${initdir}${2:-$1}
    [[ -f $target ]] && return 0
    mkdir -p "${target%/*}"
    dinfo "Installing $src" 
    cp -pfL "$src" "$target"
}

# Same as above, but specialzed to handle dynamic libraries.
# It handles making symlinks according to how the original library
# is referenced.
inst_library() {
    local src=$1 dest=${2:-$1}
    [[ -f $initdir$dest ]] && return 0
    if [[ -L $src ]]; then
	reallib=$(readlink -f "$src")
	lib=${src##*/}
	inst_simple "$reallib" "$reallib"
	mkdir -p "${initdir}${dest%/*}"
	(cd "${initdir}${dest%/*}" && ln -s "$reallib" "$lib")
    else
	inst_simple "$src" "$dest"
    fi
}

# find a binary.  If we were not passed the full path directly,
# search in the usual places to find the binary.
find_binary() {
    local binpath="/bin /sbin /usr/bin /usr/sbin" p
    [[ -z ${1##/*} && -x $1 ]] && { echo $1; return 0; } 
    for p in $binpath; do
	[[ -x $p/$1 ]] && { echo "$p/$1"; return 0; }
    done
    return 1
}

# Same as above, but specialized to install binary executables.
# Install binary executable, and all shared library dependencies, if any.
inst_binary() {
    local bin target
    bin=$(find_binary "$1") || return 1
    target=${2:-$bin}
    local LDSO NAME IO FILE ADDR I1 n f TLIBDIR
    [[ -f $initdir$target ]] && return 0
    # I love bash!
    ldd $bin 2>/dev/null | while read line; do
	[[ $line = 'not a dynamic executable' ]] && return 1
	if [[ $line =~ not\ found ]]; then
	    derror "Missing a shared library required by $bin."
	    derror "Run \"ldd $bin\" to find out what it is."
	    derror "dracut cannot create an initrd."
	    exit 1
	fi
	so_regex='([^ ]*/lib[^/]*/[^ ]*\.so[^ ]*)'
	[[ $line =~ $so_regex ]] || continue
	FILE=${BASH_REMATCH[1]}
	[[ -f ${initdir}$FILE ]] && continue
	# see if we are loading an optimized version of a shared lib.
	lib_regex='^(/lib[^/]*).*'
	if [[ $FILE =~ $lib_regex ]]; then
            TLIBDIR=${BASH_REMATCH[1]}
            BASE=${FILE##*/}
	    # prefer nosegneg libs, then unoptimized ones.
	    for f in "$TLIBDIR/i686/nosegneg" "$TLIBDIR"; do
		[[ -f $f/$BASE ]] || continue
		FILE=$f/$BASE
		break
	    done
	    inst_library "$FILE" "$TLIBDIR/$BASE"
            IF_dynamic=yes
	    continue
	fi
        inst_library "$FILE" 
    done
    inst_simple "$bin" "$target"
}

# same as above, except for shell scripts.
# If your shell script does not start with shebang, it is not a shell script.
inst_script() {
    [[ -f $1 ]] || return 1
    local line
    read -r -n 80 line <"$1"
    # If debug is set, clean unprintable chars to prevent messing up the term
    [[ $debug ]] && line=$(echo -n "$line" | tr -c -d '[:print:][:space:]')
    shebang_regex='(#! *)(/[^ ]+).*'
    [[ $line =~ $shebang_regex ]] || return 1
    inst "${BASH_REMATCH[2]}" && inst_simple "$@"
}

# same as above, but specialized for symlinks
inst_symlink() {
    local src=$1 target=$initdir${2:-$1} realsrc
    [[ -L $1 ]] || return 1
    [[ -L $target ]] && return 0
    realsrc=$(readlink -f "$src")
    [[ $realsrc = ${realsrc##*/} ]] && realsrc=${src%/*}/$realsrc
    inst "$realsrc" && ln -s "$realsrc" "$target"
}

# find a rule in the usual places.
find_rule() {
    [[ -f $1 ]] && { echo "$1"; return 0; }
    for r in . /lib/udev/rules.d /etc/udev/rules.d $dsrc/rules.d; do
	[[ -f $r/$1 ]] && { echo "$r/$1"; return 0; }
    done
    return 1
}

# udev rules always get installed in the same place, so
# create a function to install them to make life simpler.
inst_rules() { 
    local target=/etc/udev/rules.d
    mkdir -p "$initdir/lib/udev/rules.d" "$initdir$target"
    for rule in "$@"; do 
	rule=$(find_rule "$rule") && \
	    inst_simple "$rule" "$target/${rule##*/}"
    done
}

# general purpose installation function
# Same args as above.
inst() {
    if (($# != 1 && $# != 2 )); then
        derror "inst only takes 1 or 2 arguments"
	exit 1
    fi
    for x in inst_symlink inst_script inst_binary inst_simple; do
       $x "$@" && return 0
    done
    return 1
}

# install function specialized for hooks
# $1 = type of hook, $2 = hook priority (lower runs first), $3 = hook
# All hooks should be POSIX/SuS compliant, they will be sourced by init.
inst_hook() {
    if ! [[ -f $3 ]]; then
	derror "Cannot install a hook ($3) that does not exist."
	derror "Aborting initrd creation."
	exit 1
    elif ! strstr "$hookdirs" "$1"; then
	derror "No such hook type $1. Aborting initrd creation." 
	exit 1
    fi
    inst_simple "$3" "/${1}/${2}${3##*/}"
}

dracut_install() {
    if [[ $1 = '-o' ]]; then 
	local optional=yes
	shift
    fi
    while (($# > 0)); do
	if ! inst "$1" ; then
	    if [[ $optional = yes ]]; then
		dwarning "Skipping program $1 as it cannot be found and is flagged to be optional"
	    else
		derror "Failed to install $1"
		exit 1
            fi
	fi
	shift
    done
}

check_module_deps() {
    local moddir dep ret
    # if we are already set to be loaded, we do not have to be checked again.
    strstr "$mods_to_load" " $1 " && return
    # turn a module name into a directory, if we can.
    moddir=$(echo ${dsrc}/modules.d/??${1})
    [[ -d $moddir && -x $moddir/install ]] || return 1
    # if we do not have a check script, we are unconditionally included
    if [[ -x $moddir/check ]]; then
	"$moddir/check"
        ret=$?
	# a return value of 255 = load module only as a dependency.
	((ret==0||ret==255)) || return 1
	for dep in $("$moddir/check" -d); do
	    check_module_deps "$dep" && continue
	    dwarning "Dependency $mod failed."
	    return 1
	done
    fi
    mods_to_load+=" $1 "
}

should_source_module() {
    local dep
    [[ -x $1/install ]] || return 1
    if [[ $kernel_only = yes ]]; then
        [[ -x $1/installkernel ]] && return 0
        return 1
    fi
    [[ -x $1/check ]] || return 0
    "$1/check" $hostonly || return 1
    for dep in $("$1/check" -d); do
	check_module_deps "$dep" && continue
	dwarning "Cannot load $mod, dependencies failed."
	return 1
    done
}

check_modules() {
    for moddir in "$dsrc/modules.d"/[0-9][0-9]*; do
	local mod=${moddir##*/}; mod=${mod#[0-9][0-9]}
	# If we are already scheduled to be loaded, no need to check again.
	strstr "$mods_to_load" " $mod " && continue
	# This should never happen, but...
	[[ -d $moddir ]] || continue
	[[ $dracutmodules != all ]] && ! strstr "$dracutmodules" "$mod" && \
	    continue
	strstr "$omit_dracutmodules" "$mod" && continue
	if ! strstr "$add_dracutmodules" "$mod"; then
	    should_source_module "$moddir" || continue
        fi
	mods_to_load+=" $mod "
    done
}

# Install a single kernel module along with any firmware it may require.
# $1 = full path to kernel module to install
install_kmod_with_fw() {
    local modname=${1##*/} fwdir found
    modname=${modname%.ko}
    inst_simple "$1" "/lib/modules/$kernel/${1##*/lib/modules/$kernel/}"
    for fw in $(modinfo -k $kernel -F firmware $1 2>/dev/null); do
	found=''
	for fwdir in $fw_dir; do
	    if [[ -d $fwdir && -f $fwdir/$fw ]]; then
		inst_simple "$fwdir/$fw" "/lib/firmware/$fw"
		found=yes
	    fi
	done
	if [[ $found != yes ]]; then
	    dwarning "Possible missing firmware ${fw} for module ${mod}.ko"
	fi
    done
}

# Do something with all the dependencies of a kernel module.
# Note that kernel modules depend on themselves using the technique we use
# $1 = function to call for each dependency we find 
#      It will be passed the full path to the found kernel module 
# $2 = module to get dependencies for
# rest of args = arguments to modprobe
for_each_kmod_dep() {
    local func=$1 kmod=$2 cmd modpapth options
    shift 2
    modprobe "$@" --ignore-install --show-depends $kmod 2>/dev/null | \
	while read cmd modpath options; do
	    [[ $cmd = insmod ]] || continue
	    $func $modpath
    done
}

# filter kernel modules to install certian modules that meet specific
# requirements.
# $1 = function to call with module name to filter.
#      This function will be passed the full path to the module to test.
# The behaviour of this function can vary depending on whether $hostonly is set.
# If it is, we will only look at modules that are already in memory.
# If it is not, we will look at all kernel modules
# This function returns the full filenames of modules that match
filter_kernel_modules () (
    if [[ $hostonly = '' ]]; then
	for modname in $(find "$srcmods/kernel/drivers" -name '*.ko'); do
	    "$1" "$modname" && echo "$modname"
	done
    else
	while read modname rest; do
	    modname=$(modinfo -F filename -k $kernel $modname)
	    "$1" "$modname" && echo "$modname"
	done </proc/modules
    fi
)

# install kernel modules along with all their dependencies.
instmods() {
    [[ $no_kernel = yes ]] && return
    local mod mpargs modpath modname cmd
    while (($# > 0)); do
	mod=${1%.ko}
	case $mod in
	    =*) # This introduces 2 incompatible meanings for =* arguments
                # to instmods.  We need to decide which one to keep.
		if [[ $mod = =ata && -f $srcmods/modules.block ]] ; then 
		    instmods $mpargs $(egrep 'ata|ahci' "${srcmods}/modules.block")
		elif [ -f $srcmods/modules.${mod#=} ]; then
		    instmods $mpargs $(cat ${srcmods}/modules.${mod#=} )
		else
		    instmods $mpargs $(find "$srcmods" -path "*/${mod#=}/*")
		fi
		;;
	    --*) mpargs+=" $mod";;
            i2o_scsi)
                    # Must never run this diagnostic-only module
                    shift; continue;
                ;;
	    *)  mod=${mod##*/}
	        # if we are already installed, skip this module and go on
	        # to the next one.
	        [[ -f $initdir/$1 ]] && { shift; continue; }
		# If we are building a host-specific initramfs and this
		# module is not already loaded, move on to the next one.
		[[ $hostonly ]] && ! grep -q "$mod" /proc/modules && { 
		    shift; continue; 
		}
		# ok, load the module, all its dependencies, and any firmware
		# it may require
		for_each_kmod_dep install_kmod_with_fw $mod \
		    --set-version $kernel -d ${srcmods%%/lib/modules/*}/
		;;
	esac      
	shift
    done
} 

# vim:ts=8:sw=4:sts=4:et
